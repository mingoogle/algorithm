# -*- coding: utf-8 -*-

# 투포인터란?
# - 리스트에 순차적으로 접근해야할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘
# ex) 2~7번 나와봐 => 시작점과 끝점을 가지고 데이터를 가져올때

# Q.1) 특정한 합을 가지는 부분 연속수열 찾기
#      부분합이 5인 부분 연속 수열의 수는 몇 개 인가? => 시작점+끝점 = 5 인것
#      ( 조건은 연속적어야한다는거 1~3의 합이 5던가 1~2합이 5던가 // 1~4가 아닌 1+4가 5인건 안되

#   1. 시작점 과 끝점이 첫 번째 원소의 인덱스(0)을 가리키도록한다.
#   2. 현재 부분합이 M과 같다면 카운트한다.
#   3. 현재 부분합이 M보다 작으면 end를 1증가시킨다.
#   4. 현재 부분합이 M보다 크거나 같으면 start를 1증가시킨다.
#   5. 모든 경우를 확인할 때까지 2~4번까지의 과정을 반복한다.

n = 5 # 데이터개수
m = 3 # 찾고자하는 값
dataList = [1,2,3,2,5] # 수열

count = 0 # 찾은 개수
interval_sum = 0 # 부분합
end = 0

for start in range(n):
    while interval_sum < m and end < n:
        interval_sum += dataList[end]
        end += 1

    if interval_sum == m:
        count += 1
    interval_sum -= dataList[start]

print('----- 특정한 합을 가지는 부분 연속 수열 찾기 -----')
print
print(count)
print
print('----------------------------------')
print
print
print

# 정렬되어 있는 두 리스트의 합집합 O(N+M)
# Q.2) 2개의 정렬된 리스트들을 하나로 합치되 정렬되도록 합치기
#   1. 정렬된 리스트 A,B를 입력받는다.
#   2. 리스트 A에서 처리되지 않은 원소 중 가장 작은 원소를 i가 가리키도록 한다.
#   3. 리스트 B에서 처리되지 않은 원소 중 가장 작은 원소를 j가 가리키도록 한다.
#   4. A[i]와 B[j] 중에서 더 작은 원소를 결과 리스트에 담는다.
#   5. 리스트 A와B에서 더이상 처리할 원소가 없을 때까지 2~4 번의 과정을 반복한다.

# 사전에 정렬된 리스트 A와 B를 선언
n,m = 3,4
a = [1,3,5]
b = [2,4,6,8]

# A,B를 넣을 리스트를 초기화
result = [0] * (n + m)
i = 0
j = 0
k = 0

while i < n or j < m:
    # j는 이미 값을 다 넣었다면, i를 그냥 다 집어넣으면 되겠지?
    if j >= m or ( i < n and a[i] <= b[j]):
        result[k] = a[i]
        i += 1

    # i를 다 처리했다면 j만 처리하면되겠지?
    else:
        result[k] = b[j]
        j += 1
    k += 1

for i in result:
    print(i, end=' ')

print('----- 정렬되어 있는 두 리스트의 합집합 -----')
